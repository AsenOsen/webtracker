<!DOCTYPE html>

<script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.8.4/tingle.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.8.4/tingle.min.css" />
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>

<style type="text/css">
    #selector-wrapper {
        height: 100%;
        overflow-y: scroll;
        position: relative; 
    }
    #selector-wrapper > img {
        position: absolute;
        z-index: 4;
        max-width: 100%; 
    }
    #selector-wrapper > canvas {
        position: relative;
        z-index: 5;
        max-width: 100%; 
    }
    #selector-wrapper > canvas:hover {
        cursor: pointer; 
    }
</style>

<div id="selector-wrapper" style="display: none">
    <input type="hidden" id="key" value="{{ key }}">
    <img id="selector-background" src="{{ screenshot_url }}"/>
    <canvas id="selector-canvas"></canvas>
</div>
<div id="modal" style="display: none">
    <div>
        <div id="chartTitle"></div>
        <div id="chart" style="width:100%"></div>
    </div>
</div>

<script type="text/javascript">

Function.prototype.debounce = function (milliseconds, context) {
    var baseFunction = this,
        timer = null,
        wait = milliseconds;

    return function () {
        var self = context || this,
            args = arguments;

        function complete() {
            baseFunction.apply(self, args);
            timer = null;
        }

        if (timer) {
            clearTimeout(timer);
        }

        timer = setTimeout(complete, wait);
    };
};

function openModal(data)
{
    var modal = new tingle.modal({
        footer: true,
        stickyFooter: false,
        closeMethods: ['overlay', 'button', 'escape'],
        closeLabel: "Close",
        onOpen: function() {
            console.log('modal open');
        },
        onClose: function() {
            console.log('modal closed');
        },
        beforeClose: function() {
            // here's goes some logic
            // e.g. save content before closing the modal
            return true; // close the modal
            return false; // nothing happens
        }
    });
    modal.setContent($("#modal").html());
    modal.addFooterBtn('As tendency graph', 'tingle-btn tingle-btn--primary', function() {
        modal.close();
    });
    modal.addFooterBtn('As changes history', 'tingle-btn tingle-btn--danger', function() {
        modal.close();
    });

    var chartDataNumeral = {};
    var chartDataTextual = {};
    var digitsCount = 0;
    for(var ts in data) {
        var dateTime = moment.unix(parseInt(ts)).format("DD/MM/YY HH:mm");
        var yNumeral = numeral(data[ts]).value();
        if(yNumeral != null && !isNaN(yNumeral)){
            digitsCount += 1;
        }
        chartDataNumeral[dateTime] = yNumeral || 0;
        chartDataTextual[dateTime] = data[ts];
    }

    var digitPercentage = digitsCount / Object.keys(chartDataNumeral).length;
    var isDigitalGraph = digitPercentage >= 0.5
    var chartData = {};

    // TODO: algorithm of determining whether graph should be digital or textual
    // can be better: if numeral`ed digit is not substr`ed within contents
    // maybe it is better to build graph as changes graph (requires research) 
    if(isDigitalGraph) {
        chartData = chartDataNumeral;
    } else {
        var changesCounter = 0;
        var prevText = "<random data>";
        for(var key in chartDataTextual){
            var newText = chartDataTextual[key];
            if(newText != prevText) {
                changesCounter += 1;
            }
            chartData[key] = changesCounter;
            prevText = newText;
        }
    }

    //console.log(chartData);
    var data = [
        {
            x: Object.keys(chartData),
            y: Object.values(chartData),
            type: 'line'
        }
    ];
    $("#chartTitle").text(isDigitalGraph ? "Tendency" : "Changes");
    modal.open();
    Plotly.newPlot('chart', data);
    
}

$(document).ready(function () {

    var current_selected_xpath = false;
    var state_clicked = false;

    var c;

    // greyed out fill context
    var xctx;
    // redline highlight context
    var ctx;

    var current_default_xpath = [];
    var x_scale = 1;
    var y_scale = 1;
    var selector_image;
    var selector_image_rect;
    var selector_data;

    bootstrap_visualselector();

    function bootstrap_visualselector() {
        if (1) {
            // bootstrap it, this will trigger everything else
            $("img#selector-background").bind('load', function () {
                console.log("Loaded background...");
                c = document.getElementById("selector-canvas");
                // greyed out fill context
                xctx = c.getContext("2d");
                // redline highlight context
                ctx = c.getContext("2d");
                current_default_xpath = [];
                fetch_data();
                $('#selector-canvas').off("mousemove mousedown");
            });
        }
        // Tell visualSelector that the image should update
        var s = $("img#selector-background").attr('src')+"?"+ new Date().getTime();
        $("img#selector-background").attr('src',s)
    }

    function fetch_data() {
        // Image is ready
        $('.fetching-update-notice').html("Fetching element data..");

        $.get({
            url: "/xpath",
            data: {
                "key": $("#key").val()
            },
            context: document.body
        }).done(function (data) {
            $('.fetching-update-notice').html("Rendering..");
            selector_data = data;
            console.log("Reported browser width from backend: " + data['browser_width']);
            state_clicked = false;
            set_scale();
            reflow_selector();
            $('.fetching-update-notice').fadeOut();
        });
    };


    function set_scale() {

        // some things to check if the scaling doesnt work
        // - that the widths/sizes really are about the actual screen size cat elements.json |grep -o width......|sort|uniq
        $("#selector-wrapper").show();
        selector_image = $("img#selector-background")[0];
        selector_image_rect = selector_image.getBoundingClientRect();

        // make the canvas the same size as the image
        $('#selector-canvas').attr('height', selector_image_rect.height);
        $('#selector-canvas').attr('width', selector_image_rect.width);
        $('#selector-wrapper').attr('width', selector_image_rect.width);
        x_scale = selector_image_rect.width / selector_data['browser_width'];
        y_scale = selector_image_rect.height / selector_image.naturalHeight;
        ctx.strokeStyle = 'rgba(255,0,0, 0.9)';
        ctx.fillStyle = 'rgba(255,0,0, 0.1)';
        ctx.lineWidth = 3;
        console.log("scaling set  x: " + x_scale + " by y:" + y_scale);
    }

    function reflow_selector() {
        $(window).resize(function () {
            set_scale();
            highlight_current_selected_xpath();
        });

        set_scale();

        console.log(selector_data['xpath'].length + " selectors found");

        // highlight the default one if we can find it in the xPath list
        // or the xpath matches the default one
        found = false;
        if (current_default_xpath.length) {
            // Find the first one that matches
            // @todo In the future paint all that match
            for (const c of current_default_xpath) {
                for (var xpath in selector_data['xpath']) {
                    if (xpath === c) {
                        console.log("highlighting " + c);
                        current_selected_xpath = xpath;
                        highlight_current_selected_xpath();
                        found = true;
                        break;
                    }
                }
                if (found) {
                    break;
                }
            }
            if (!found) {
                alert("Unfortunately your existing CSS/xPath Filter was no longer found!");
            }
        }


        $('#selector-canvas').bind('mousemove', function (e) {
            if (state_clicked) {
                return;
            }
            ctx.clearRect(0, 0, c.width, c.height);
            current_selected_xpath = null;

            // Add in offset
            if ((typeof e.offsetX === "undefined" || typeof e.offsetY === "undefined") || (e.offsetX === 0 && e.offsetY === 0)) {
                var targetOffset = $(e.target).offset();
                e.offsetX = e.pageX - targetOffset.left;
                e.offsetY = e.pageY - targetOffset.top;
            }

            // Reverse order - the most specific one should be deeper/"laster"
            // Basically, find the most 'deepest'
            var found = null;
            var min_square = Infinity;
            ctx.fillStyle = 'rgba(205,0,0,0.35)';
            for (var xpath in selector_data['xpath']) {
                // draw all of them? let them choose somehow?
                var sel = selector_data['xpath'][xpath];
                // If we are in a bounding-box
                var intersected = (e.offsetY > sel.top * y_scale && e.offsetY < sel.top * y_scale + sel.height * y_scale) 
                    && (e.offsetX > sel.left * y_scale && e.offsetX < sel.left * y_scale + sel.width * y_scale);
                if (intersected && sel.width * sel.height < min_square) {

                    // FOUND ONE
                    found = sel;

                    // no need to keep digging
                    // @todo or, O to go out/up, I to go in
                    // or double click to go up/out the selector?
                    current_selected_xpath = xpath;
                    min_square = sel.width * sel.height;
                    //break;
                }
            }

            if(found != null){
                ctx.strokeRect(found.left * x_scale, found.top * y_scale, found.width * x_scale, found.height * y_scale);
                ctx.fillRect(found.left * x_scale, found.top * y_scale, found.width * x_scale, found.height * y_scale);
            }
            
        }.debounce(5));

        function highlight_current_selected_xpath() {
            if (state_clicked) {
                state_clicked = false;
                xctx.clearRect(0, 0, c.width, c.height);
                return;
            }

            var sel = selector_data['xpath'][current_selected_xpath];
            xctx.fillStyle = 'rgba(205,205,205,0.95)';
            xctx.strokeStyle = 'rgba(225,0,0,0.9)';
            xctx.lineWidth = 3;
            xctx.fillRect(0, 0, c.width, c.height);
            // Clear out what only should be seen (make a clear/clean spot)
            xctx.clearRect(sel.left * x_scale, sel.top * y_scale, sel.width * x_scale, sel.height * y_scale);
            xctx.strokeRect(sel.left * x_scale, sel.top * y_scale, sel.width * x_scale, sel.height * y_scale);
            state_clicked = true;

            console.log(numeral(sel.text));
            $.get({
                url: "/history",
                data: {
                    "key": $("#key").val(),
                    "xpath": current_selected_xpath
                }
            }).done(function (data) {
                openModal(data);
            });
        }


        $('#selector-canvas').bind('click', function (e) {
            highlight_current_selected_xpath(); 
        });
    }

});
</script>