<!DOCTYPE html>

<script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.8.4/tingle.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.8.4/tingle.min.css" />
<script src="https://cdn.plot.ly/plotly-2.16.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/diff2html@2.9.0/dist/diff2html.min.js"></script>

<style type="text/css">
    #selector-wrapper {
        height: 100%;
        overflow-y: scroll;
        position: relative; 
    }
    #selector-wrapper > img {
        position: absolute;
        z-index: 4;
        max-width: 100%; 
    }
    #selector-wrapper > canvas {
        position: relative;
        z-index: 5;
        max-width: 100%; 
    }
    #selector-wrapper > canvas:hover {
        cursor: pointer; 
    }
</style>

<div id="selector-wrapper" style="display: none">
    <input type="hidden" id="key" value="{{ key }}">
    <img id="selector-background" src="{{ screenshot_url }}"/>
    <canvas id="selector-canvas"></canvas>
</div>
<div id="modal" style="display: none">
    <div>
        <div id="chartTitle"></div>
        <div id="chart" style="width:100%"></div>
        <table id="changes" style="width:100%" border="1">
        </table>
    </div>
</div>

<script type="text/javascript">

var state_clicked = false;
var canvas;
// greyed out fill context
var xctx;
// redline highlight context
var ctx;
var x_scale = 1;
var y_scale = 1;
var selector_data;

function openModal(data)
{
    var modal = new tingle.modal({
        footer: true,
        stickyFooter: false,
        closeMethods: ['overlay', 'button', 'escape'],
        closeLabel: "Close",
        onOpen: function() {
            console.log('modal open');
        },
        onClose: function() {
            console.log('modal closed');
        },
        beforeClose: function() {
            // here's goes some logic
            // e.g. save content before closing the modal
            return true; // close the modal
            return false; // nothing happens
        }
    });
    modal.setContent($("#modal").html());
    modal.addFooterBtn('As tendency', 'tingle-btn tingle-btn--primary', function() {
        modal.close();
    });
    modal.addFooterBtn('As changes', 'tingle-btn tingle-btn--danger', function() {
        modal.close();
    });

    var chartDataNumeral = {};
    var chartDataTextual = {};
    var digitsCount = 0;
    for(var ts in data) {
        var contents = data[ts];
        var dateTime = moment.unix(parseInt(ts)).format("DD/MM/YY HH:mm");
        var yNumeral = numeral(contents).value();
        if(yNumeral != null && !isNaN(yNumeral)){
            digitsCount += 1;
        }
        chartDataNumeral[dateTime] = yNumeral || 0;
        chartDataTextual[dateTime] = contents;
    }

    var labels = Object.values(chartDataTextual).map(x => String(x).substr(0,50));
    var digitPercentage = digitsCount / Object.keys(chartDataNumeral).length;
    var isDigitalGraph = digitPercentage >= 0.5
    var chartData = {};

    // TODO: algorithm of determining whether graph should be digital or textual
    // can be better: if numeral`ed digit is not substr`ed within contents
    // maybe it is better to build graph as changes graph (requires research) 
    if(isDigitalGraph) {
        chartData = chartDataNumeral;
    } else {
        var changesCounter = 0;
        var prevText = null;
        var table = $("#changes");
        for(var key in chartDataTextual){
            var newText = chartDataTextual[key];
            if(newText != prevText && prevText != null) {
                changesCounter += 1;
            }
            chartData[key] = changesCounter;
            newText = newText||"";
            if (prevText == null){
                prevText = newText;
            }
            var diff = Diff.diffLines(prevText, newText);
            prevText = newText;

            var diffHtml = $("<div></div>");
            var changed = false;
            diff.forEach((part) => {
                changed |= (part.added || part.removed);
              const color = part.added ? 'green' :
                part.removed ? 'red' : 'black';
              var span = $("<span>" + part.value + "</span>");
              $(span).css('color', color);
              $(diffHtml).append(span)
            });

            if(changed){
                var tr = $("<tr></tr>");
                var td1 = $("<td>" + key + "</td>");
                var td2 = $("<td></td>");
                $(td2).append(diffHtml);
                $(tr).append(td1);
                $(tr).append(td2);
                table.append(tr);
            }
        }
    }

    //console.log(chartData);
    var data = [
        {
            x: Object.keys(chartData),
            y: Object.values(chartData),
            text: labels,
            type: 'line'
        }
    ];

    $("#chartTitle").text(isDigitalGraph ? "Tendency" : "Changes");
    modal.open();
    Plotly.newPlot('chart', data);
}

function bootstrapSelector() 
{
    // bootstrap it, this will trigger everything else
    $("img#selector-background").bind('load', function () {
        console.log("Loaded background");
        canvas = document.getElementById("selector-canvas");
        xctx = canvas.getContext("2d");
        ctx = canvas.getContext("2d");
        loadXpath();
    });
    // Tell visualSelector that the image should update
    var s = $("img#selector-background").attr('src')+"?"+ new Date().getTime();
    $("img#selector-background").attr('src',s)
}

function loadXpath() 
{
    $.get({
        url: "/xpath",
        data: {
            "key": $("#key").val()
        }
    }).done(function (data) {
        console.log("Reported browser width from backend: " + data['browser_width']);
        selector_data = data;
        initView();
    });
}

function resetScale() 
{
    // some things to check if the scaling doesnt work
    // - that the widths/sizes really are about the actual screen size cat elements.json |grep -o width......|sort|uniq
    $("#selector-wrapper").show();
    var selector_image = $("img#selector-background")[0];
    var selector_image_rect = selector_image.getBoundingClientRect();

    // make the canvas the same size as the image
    $('#selector-canvas').attr('height', selector_image_rect.height);
    $('#selector-canvas').attr('width', selector_image_rect.width);
    $('#selector-wrapper').attr('width', selector_image_rect.width);
    x_scale = selector_image_rect.width / selector_data['browser_width'];
    y_scale = selector_image_rect.height / selector_image.naturalHeight;
    ctx.strokeStyle = 'rgba(255,0,0, 0.9)';
    ctx.fillStyle = 'rgba(255,0,0, 0.1)';
    ctx.lineWidth = 3;
    console.log("scaling set  x: " + x_scale + " by y:" + y_scale);
}

function initView() 
{
    $(window).resize(function () {
        clearSelection();
        resetScale();
    });

    resetScale();
    $('#selector-canvas').bind('mousemove', onCanvasMove);
    $('#selector-canvas').bind('click', onCanvasClicked);
}

function findHoveredXpath(e)
{
     // Add in offset
    if ((typeof e.offsetX === "undefined" || typeof e.offsetY === "undefined") || (e.offsetX === 0 && e.offsetY === 0)) {
        var targetOffset = $(e.target).offset();
        e.offsetX = e.pageX - targetOffset.left;
        e.offsetY = e.pageY - targetOffset.top;
    }

    var x = e.offsetX;
    var y = e.offsetY;

    // the smallest possible square
    var hoveredElementXpath = null;
    var min_square = Infinity;
    ctx.fillStyle = 'rgba(205,0,0,0.35)';
    for (var xpath in selector_data['xpath']) {
        var sel = selector_data['xpath'][xpath];
        var intersected = 
            (y > sel.top * y_scale && y < sel.top * y_scale + sel.height * y_scale) 
            && 
            (x > sel.left * y_scale && x < sel.left * y_scale + sel.width * y_scale);
        var lessSquare = sel.width * sel.height < min_square;
        if (intersected && lessSquare) {
            hoveredElementXpath = xpath;
            min_square = sel.width * sel.height;
        }
    }

    return hoveredElementXpath;
}

function onCanvasMove(e)
{
    if (state_clicked) {
        return;
    }

    clearSelection();

    var hoveredXpath = findHoveredXpath(e);
    var element = hoveredXpath ? selector_data['xpath'][hoveredXpath] : null;

    if(element){
        ctx.strokeRect(
            element.left * x_scale, element.top * y_scale, 
            element.width * x_scale, element.height * y_scale
            );
        ctx.fillRect(
            element.left * x_scale, element.top * y_scale, 
            element.width * x_scale, element.height * y_scale
            );
    }   
}

function clearSelection()
{
    state_clicked = false;
    xctx.clearRect(0, 0, canvas.width, canvas.height);
}

function onCanvasClicked(e) 
{
    if (state_clicked) {
       clearSelection();
       return;
    }

    var hoveredXpath = findHoveredXpath(e);
    if(!hoveredXpath) {
        console.log("No element found under mouse click coordinates");
        return;
    }

    var sel = selector_data['xpath'][hoveredXpath];
    xctx.fillStyle = 'rgba(205,205,205,0.95)';
    xctx.strokeStyle = 'rgba(225,0,0,0.9)';
    xctx.lineWidth = 3;
    xctx.fillRect(0, 0, canvas.width, canvas.height);
    // Clear out what only should be seen (make a clear/clean spot)
    xctx.clearRect(sel.left * x_scale, sel.top * y_scale, sel.width * x_scale, sel.height * y_scale);
    xctx.strokeRect(sel.left * x_scale, sel.top * y_scale, sel.width * x_scale, sel.height * y_scale);
    state_clicked = true;

    $.get({
        url: "/history",
        data: {
            "key": $("#key").val(),
            "xpath": hoveredXpath
        }
    }).done(function (data) {
        openModal(data);
    });
}

$(document).ready(bootstrapSelector);
</script>